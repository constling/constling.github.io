---
layout: post
title:  "Spring框架学习"
date:   2019-05-26 22:05:00
categories: 其它
---

## Spring架构
**概念**
1. 依赖倒置：
上层模块不应该依赖于下层模块，它们共同依赖于一个抽象。抽象不能依赖于具象，具象依赖于抽象。

2. 控制反转
模块与模块之间通过抽象来建立连接。具体使用的模块，交由配置文件来控制，实现控制转移。
控制反转IoC，是说对象的控制权进行转移，转移到第三方。比如转移交给了IoC容器，它就是一个创建工厂，你要什么对象，它就给你什么对象，有了IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。
[链接](https://www.cnblogs.com/Mr-Rocker/p/7721824.html)

3. 面向切面aop
[链接](https://www.cnblogs.com/Wolfmanlq/p/6036019.html)


### Spring
Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。

**Spring是什么**
Spring是一个库，它的功能是提供了一个软件框架，这个框架目的是使软件之间的逻辑更加清晰，配置更灵活，实现这个目的的手段使用AOP和IoC。

**Spring的优势**
* Spring轻量，大约2mb。
* 提供IOC的控制反转，解少模块间的依赖。
* 提供AOP面向切面的框架，将应用业务与系统业务分开。
* 提供容器，实现对象的生命周期管理。
* MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。
* 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。
* 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。

**spring教程**
[链接](https://www.yiibai.com/spring/spring-tutorial-for-beginners.html)

**特点**
1. 轻量
2. 控制反转
3. 面向切面

**context对于bean的好处**
* bean关注的是一个对象的抽象化。比如使用数据库的属性、名称等。
* context将无关的内容配置化，编程只用关注接口内容。比如：数据库访问，不用关心数据库的名称、方式。只用使用数据库的读写、存储等。


**Spring for Jdbc的意义**
* 统一管理连接。
* 节省Jdbc操作重复代码封装与编写。

**JdbcTemplate的优点**
* 配置基于模板设置
* 完成了资源的创建和释放的工作
* 完成了对JDBC的核心流程的工作，包括SQL语句的创建和执行，简化了对JDBC的操作
* 仅需要传递DataSource就可以把它实例化
* JdbcTemplate只需要创建一次，减少了代码复用的烦恼
* JdbcTemplate是线程安全类

**Java持久化**
[待学习链接](https://blog.csdn.net/qq_39470733/article/details/80166949)

**相关学习**
* [Maven链接](https://www.yiibai.com/maven/)
* [Spring](https://www.w3cschool.cn/wkspring/pesy1icl.html)

## ORM架构

**myBatis与Hibernate相比主要优势**
**Redis持久化有哪些方式**
**Nignx与Apache的原理及不同**

**面向切面的实现原理**
通过代理对象实现。

**定义自己的原则**
[待学习]


##数据持久化存储
### redis
学习网址：
https://www.cnblogs.com/jasontec/p/9699242.html

1. redis有哪些架构

**主从复制**
特点：
* 具有master/slave角色。
* master/slave数据相同。
* 降低master读压力在从库。

问题：
* 无法保证高可用。
* 没有解决master写的压力。

**哨兵**
主从模式下面增加‘哨兵’监控机制，保证高可用。

**集群**
redis cluster，主要是针对海量数据+高并发+高可用的场景，海量数据，如果你的数据量很大，那么建议就用redis cluster

* 将数据进行分片，每个master上放一部分数据。
* 提供高可用支持，部分master不可用时，可以继续工作。

* 支撑N个redis master node，每个master node都可以挂载多个slave node
高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master。

**集群代理型**

**集群直连型**

**数据分布算法**
1. 顺序分布
* 数据分散易倾斜
* 键值业务相关
* 可顺序访问
* 支持批量操作

2. 哈希分布
* 数据分散度高
* 键值分布业务无关
* 无法顺序访问
* 支持批量操作

哈希分布分为：节点取余区、一致性哈希分区、虚拟cao分区。
https://blog.csdn.net/qq_27862335/article/details/81771812

一致性哈希：
https://www.cnblogs.com/lpfuture/p/5796398.html

### 一致性Hash性质
考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要，良好的分布式cahce系统中的一致性hash算法应该满足以下几个方面：
* 平衡性(Balance)
* 单调性
* 分散性
* 负载
* 平滑性

**Redis实现分布式锁一**
https://baijiahao.baidu.com/s?id=1623086259657780069&wfr=spider&for=pc


## 服务端设计理念
1. 高可用。
2. 可靠。


## 面试
1. 定义清楚问题
2. 思考、分析问题
3. 解决问题步骤
4. 更进一步思考


## memcache
memcache是一套分布式的对象缓存系统，基于内存的key-value存储。

**特征**
* 协议简单。
* 基于libevent的事件处理。
* 内置内存存储方式。
* memcached不互相通信的分布式。


1.memcache与redis的区别和联系
* 存储方式不同
memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。 

* 数据支持类型不同
redis在数据支持上要比memecache多的多。

* 使用底层模型不同
新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 

* 运行环境不同 
redis目前官方只支持LINUX 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。

1. Redis是什么
这个问题的结果影响了我们怎么用Redis。如果你认为Redis是一个key value store, 那可能会用它来代替MySQL；如果认为它是一个可以持久化的cache, 可能只是它保存一些频繁访问的临时数据。Redis是REmote DIctionary Server的缩写，在Redis在官方网站的的副标题是A persistent key-value database with built-in net interface written in ANSI-C for Posix systems，这个定义偏向key value store。还有一些看法则认为Redis是一个memory database，因为它的高性能都是基于内存操作的基础。另外一些人则认为Redis是一个data structure server，因为Redis支持复杂的数据特性，比如List, Set等。对Redis的作用的不同解读决定了你对Redis的使用方式。
互联网数据目前基本使用两种方式来存储，关系数据库或者key value。但是这些互联网业务本身并不属于这两种数据类型，比如用户在社会化平台中的关系，它是一个list，如果要用关系数据库存储就需要转换成一种多行记录的形式，这种形式存在很多冗余数据，每一行需要存储一些重复信息。如果用key value存储则修改和删除比较麻烦，需要将全部数据读出再写入。Redis在内存中设计了各种数据类型，让业务能够高速原子的访问这些数据结构，并且不需要关心持久存储的问题，从架构上解决了前面两种存储需要走一些弯路的问题。
2. Redis不可能比Memcache快
很多开发者都认为Redis不可能比Memcached快，Memcached完全基于内存，而Redis具有持久化保存特性，即使是异步的，Redis也不可能比Memcached快。但是测试结果基本是Redis占绝对优势。一直在思考这个原因，目前想到的原因有这几方面。
Libevent。和Memcached不同，Redis并没有选择libevent。Libevent为了迎合通用性造成代码庞大(目前Redis代码还不到libevent的1/3)及牺牲了在特定平台的不少性能。Redis用libevent中两个文件修改实现了自己的epoll event loop(4)。业界不少开发者也建议Redis使用另外一个libevent高性能替代libev，但是作者还是坚持Redis应该小巧并去依赖的思路。一个印象深刻的细节是编译Redis之前并不需要执行./configure。
CAS问题。CAS是Memcached中比较方便的一种防止竞争修改资源的方法。CAS实现需要为每个cache key设置一个隐藏的cas token，cas相当value版本号，每次set会token需要递增，因此带来CPU和内存的双重开销，虽然这些开销很小，但是到单机10G+ cache以及QPS上万之后这些开销就会给双方相对带来一些细微性能差别(5)。
3. 单台Redis的存放数据必须比物理内存小
Redis的数据全部放在内存带来了高速的性能，但是也带来一些不合理之处。比如一个中型网站有100万注册用户，如果这些资料要用Redis来存储，内存的容量必须能够容纳这100万用户。但是业务实际情况是100万用户只有5万活跃用户，1周来访问过1次的也只有15万用户，因此全部100万用户的数据都放在内存有不合理之处，RAM需要为冷数据买单。
这跟操作系统非常相似，操作系统所有应用访问的数据都在内存，但是如果物理内存容纳不下新的数据，操作系统会智能将部分长期没有访问的数据交换到磁盘，为新的应用留出空间。现代操作系统给应用提供的并不是物理内存，而是虚拟内存(Virtual Memory)的概念。
基于相同的考虑，Redis 2.0也增加了VM特性。让Redis数据容量突破了物理内存的限制。并实现了数据冷热分离。
4. Redis的VM实现是重复造轮子
Redis的VM依照之前的epoll实现思路依旧是自己实现。但是在前面操作系统的介绍提到OS也可以自动帮程序实现冷热数据分离，Redis只需要OS申请一块大内存，OS会自动将热数据放入物理内存，冷数据交换到硬盘，另外一个知名的“理解了现代操作系统(3)”的Varnish就是这样实现，也取得了非常成功的效果。
作者antirez在解释为什么要自己实现VM中提到几个原因(6)。主要OS的VM换入换出是基于Page概念，比如OS VM1个Page是4K, 4K中只要还有一个元素即使只有1个字节被访问，这个页也不会被SWAP, 换入也同样道理，读到一个字节可能会换入4K无用的内存。而Redis自己实现则可以达到控制换入的粒度。另外访问操作系统SWAP内存区域时block进程，也是导致Redis要自己实现VM原因之一。
5. 用get/set方式使用Redis
作为一个key value存在，很多开发者自然的使用set/get方式来使用Redis，实际上这并不是最优化的使用方法。尤其在未启用VM情况下，Redis全部数据需要放入内存，节约内存尤其重要。
假如一个key-value单元需要最小占用512字节，即使只存一个字节也占了512字节。这时候就有一个设计模式，可以把key复用，几个key-value放入一个key中，value再作为一个set存入，这样同样512字节就会存放10-100倍的容量。
这就是为了节约内存，建议使用hashset而不是set/get的方式来使用Redis，详细方法见参考文献(7)。
6. 使用aof代替snapshot
Redis有两种存储方式，默认是snapshot方式，实现方法是定时将内存的快照(snapshot)持久化到硬盘，这种方法缺点是持久化之后如果出现crash则会丢失一段数据。因此在完美主义者的推动下作者增加了aof方式。aof即append only mode，在写入内存数据的同时将操作命令保存到日志文件，在一个并发更改上万的系统中，命令日志是一个非常庞大的数据，管理维护成本非常高，恢复重建时间会非常长，这样导致失去aof高可用性本意。另外更重要的是Redis是一个内存数据结构模型，所有的优势都是建立在对内存复杂数据结构高效的原子操作上，这样就看出aof是一个非常不协调的部分。
其实aof目的主要是数据可靠性及高可用性，在Redis中有另外一种方法来达到目的：Replication。由于Redis的高性能，复制基本没有延迟。这样达到了防止单点故障及实现了高可用。
小结
要想成功使用一种产品，我们需要深入了解它的特性。Redis性能突出，如果能够熟练的驾驭，对国内很多大型应用具有很大帮助。

可以实现存放数据的有redis、memcache、ssdb等
redis能够实现持久化，将数据序列化到本地磁盘可供备份，有容灾的效果。当服务器断电或其他故障重新启动redis服务后，可以读取磁盘中被持久化的数据。
这一点我们可以通过redis前台启动观察，控制台上有日志记录（带有RDB字样的内容），这个过程就是将redis内存中的数据写到磁盘上。
为防止数据丢失，需要将 Redis 中的数据从内存中 dump 到磁盘，这就是持久化。Redis 提供两种持久化方式：RDB 和 AOF。Redis 允许两者结合，也允许两者同时关闭，默认使用RDB。
RDB持久化策略：
save 900 1  900秒内有一个key发生改变时执行序列化
save 300 10 300秒内有十个key发生改变时执行序列化
save 60 10000  60秒内有一万个key发生改变时执行序列化
AOF持久化：策略
appendfsync always 总是序列化
appendfsync everysec
appendfsync no
显然AOF持久化数据完整性能更高，缺点是生成大量的日志文件。
2.memcache 不支持持久化操作，数据结构单一，只有string类型。
3.现在有些公司使用redis和ssdb组合的方式。
ssdb写的效率高，redis读的效率高，两者结合可以达到优势互补的效果，但是这也依赖一个lua脚本，两者共用一套客户端（redis-cli）。
4.redis中存储如果key相同那么就是执行更新操作，如何定义key才能保证数据的安全有效呢？
key取值不能过长（效率低）也不能过短（可读性差）
以user表为例，有主键id和username等字段

## memcached
http://youzhixueyuan.com/memcached-answers-to-interview-questions.html

## RPC
https://www.jianshu.com/p/2accc2840a1b

1. 常见rpc框架
支持Java最多，golang

Netty - Netty框架不局限于RPC，更多的是作为一种网络协议的实现框架，比如HTTP，由于RPC需要高效的网络通信，就可能选择以Netty作为基础。
brpc是一个基于protobuf接口的RPC框架，在百度内部称为“baidu-rpc”，它囊括了百度内部所有RPC协议，并支持多种第三方协议，从目前的性能测试数据来看，brpc的性能领跑于其他同类RPC产品。
Dubbo是Alibaba开发的一个RPC框架，远程接口基于Java Interface, 依托于Spring框架。
gRPC的Java实现的底层网络库是基于Netty开发而来，其Go实现是基于net库。
Thrift是Apache的一个项目(http://thrift.apache.org)，前身是Facebook开发的一个RPC框架，采用thrift作为IDL (Interface description language)。
jsonrpc。

https://www.jianshu.com/p/b0343bfd216e

## RPC问题
1. 什么是rpc。
2. 为什么要用rpc。
3. rpc解决的三个问题。
RPC要达到的目标：远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

Call ID映射。我们怎么告诉远程机器我们要调用哪个函数呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用具体函数，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，是无法调用函数指针的，因为两个进程的地址空间是完全不一样。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
网络传输。远程调用往往是基于网络的，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。

https://www.cnblogs.com/feifeicui/p/10431529.html

