---
layout: post
title:  "Java语言"
date:   2019-06-30 22:00:00
categories: 面试
---

## java简介

Java分三个版本: JavaSE(标准版)、JavaEE(企业版)、JavaME(微型版) ，其中JavaSE 是Java编程语言的基础, JavaEE是用于公司的PC端开发的，而JavaME是用于移动端开发的。

**Java SE ( Java Platform , Standard Edition )**

Java SE以前称为J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的Java 应用程序。
Java SE包含了支持Java Web服务开发的类,为Java Platform ，Enterprise Edition ( JavaEE )提供基础。

**Java EE( Java Platform , Enterprise Edition )**

这个版本以前称为J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。
JavaEE是在JavaSE的基础上构建的,它提供Web服务、组件模型、管理和通信API ,可以用来实现企业级的面向服务体系结构( service-orientedarchitecture , SOA )和Web 2.0应用程序。

**Java ME ( Java Platform , Micro Edition )**

这个版本以前称为J2ME。Java ME为在移动设备和嵌入式设备(比如手机、PDA、电视机顶盒和打印机)上运行的应用程序提供一 个健壮且灵活的环境。
Java ME包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。

## java语言
**Java修饰符**

* 访问控制修饰符 : default, public , protected, private
* 非访问控制修饰符 : final, abstract, static, synchronized

**synchronized修饰符**

* 某个对象实例内，synchronized aMethod(){}关键字可以防止多个线程访问对象的synchronized方法。
* synchronized关键字是不能继承的。

* 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

* 当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

**HashTable**

HashTable是一个散列表，存储内容是键值对映射。继承于Dictionary，提供线程安全的同步函数。
HashTable实例有两个参数：初始容量和加载因子。
加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容

[实现原理](https://www.cnblogs.com/owenma/p/8554568.html)

**HashTable和Dictionary的区别**

* HashTable不支持泛型，而Dictionary支持泛型。
* Hashtable 的元素属于 Object 类型，所以在存储或检索值类型时通常发生装箱和拆箱的操作，所以你可能需要进行一些类型转换的操作，而且对于int,float这些值类型还需要进行装箱等操作，非常耗时。
* 单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分。多线程程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型. 而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。

## java ee
* [学习链接](https://blog.csdn.net/master_yao/article/details/61672910)

## java bean?

**类加载器**

一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，其它类等到jvm用到的时候再加载。这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现。


**finalize**
finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。

* [链接](https://blog.csdn.net/Justin_zhao/article/details/74358828)

**JNI**
Java Natibe Inetrface：Java 是跨平台的语言，但是在有些时候仍然是有需要调用本地代码。

**volatile**
多线程并发访问对象的变量时。对象的变量被拷贝到线程的内存区域。多线程并发访问不正确。

**符号==**
==就是用来比较值是否相等。

**其它**
* a = a + b，当类型不匹配时会报错。a += b，则会自动转换。


**GC策略**
1. 标记-清除算法
2. 复制算法
3. 标记-整理算法


**数据区**
java运行数据区：[链接](https://www.cnblogs.com/dolphin0520/p/3613043.html)
* 程序计数器
* Java栈
* 本地方法栈
* 方法区
* 堆

**StringBuffer & StringBuilder**
* StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，
* 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，
而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 
* 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低。

**类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候**

* 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
* 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
结论：对象初始化的顺序，先静态方法，再构造方法，每个又是先基类后子类
* 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
* 父类构造方法
* 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
* 子类构造方法

**Class.forName和ClassLoader的区别**

**Java类装载过程**
* 装载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象；
* 链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；
	* 校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证）
	* 准备：给类的静态变量分配并初始化存储空间； 
	* 解析：将常量池中的符号引用转成直接引用； 
* 初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。 

**Java GC**

1. 新生代有一个Eden区和两个survivor区，首先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。
2. 大对象以及长期存活的对象直接进入老年区。
3. 当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。
对什么东西：从GC Roots搜索不到，而且经过一次标记清理之后仍没有复活的对象。
做什么： 新生代：复制清理； 老年代：标记-清除和标记-压缩算法； 永久代：存放Java中的类和加载类的类加载器本身。
GC Roots都有哪些： 1. 虚拟机栈中的引用的对象 2. 方法区中静态属性引用的对象，常量引用的对象 3. 本地方法栈中JNI（即一般说的Native方法）引用的对象。

[清理算法](https://blog.csdn.net/wuzhiwei549/article/details/80563134)

**wait和sleep的区别**
* sleep来自Thread类，和wait来自Object类
* 调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
* sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU
* sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒

**HashMap & ConcurrentHashMap**
**显示锁&内置锁的区别**