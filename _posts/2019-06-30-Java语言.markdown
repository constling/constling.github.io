---
layout: post
title:  "Java语言"
date:   2019-06-30 22:00:00
categories: 面试
---

## java简介

Java分三个版本: JavaSE(标准版)、JavaEE(企业版)、JavaME(微型版) ，其中JavaSE 是Java编程语言的基础, JavaEE是用于公司的PC端开发的，而JavaME是用于移动端开发的。

**Java SE ( Java Platform , Standard Edition )**

Java SE以前称为J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的Java 应用程序。
Java SE包含了支持Java Web服务开发的类,为Java Platform ，Enterprise Edition ( JavaEE )提供基础。

**Java EE( Java Platform , Enterprise Edition )**

这个版本以前称为J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。
JavaEE是在JavaSE的基础上构建的,它提供Web服务、组件模型、管理和通信API ,可以用来实现企业级的面向服务体系结构( service-orientedarchitecture , SOA )和Web 2.0应用程序。

**Java ME ( Java Platform , Micro Edition )**

这个版本以前称为J2ME。Java ME为在移动设备和嵌入式设备(比如手机、PDA、电视机顶盒和打印机)上运行的应用程序提供一 个健壮且灵活的环境。
Java ME包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。

## java语言
**Java修饰符**

* 访问控制修饰符 : default, public , protected, private
* 非访问控制修饰符 : final, abstract, static, synchronized

**synchronized修饰符**

* 某个对象实例内，synchronized aMethod(){}关键字可以防止多个线程访问对象的synchronized方法。
* synchronized关键字是不能继承的。

* 当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

* 当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

**HashTable**

HashTable是一个散列表，存储内容是键值对映射。继承于Dictionary，提供线程安全的同步函数。
HashTable实例有两个参数：初始容量和加载因子。
加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容

[实现原理](https://www.cnblogs.com/owenma/p/8554568.html)

**HashTable和Dictionary的区别**

* HashTable不支持泛型，而Dictionary支持泛型。
* Hashtable 的元素属于 Object 类型，所以在存储或检索值类型时通常发生装箱和拆箱的操作，所以你可能需要进行一些类型转换的操作，而且对于int,float这些值类型还需要进行装箱等操作，非常耗时。
* 单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分。多线程程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型. 而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。

## java面试题目
**java内存模型**
java运行时数据分为六种：
* 程序计数器：线程独立，用于保存当前正常执行的程序的内存地址。
* java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。
* 本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。
* Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。
* 方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。
* 运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。

**GC策略**

1. 新生代有一个Eden区和两个survivor区，首先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。
2. 大对象以及长期存活的对象直接进入老年区。
3. 当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。
对什么东西：从GC Roots搜索不到，而且经过一次标记清理之后仍没有复活的对象。
做什么： 新生代：复制清理； 老年代：标记-清除和标记-压缩算法； 永久代：存放Java中的类和加载类的类加载器本身。

GC Roots都有哪些： 

1. 虚拟机栈中的引用的对象
2. 方法区中静态属性引用的对象，常量引用的对象
3. 本地方法栈中JNI（即一般说的Native方法）引用的对象。

[清理算法](https://blog.csdn.net/wuzhiwei549/article/details/80563134)

**finalize**

finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。

* [链接](https://blog.csdn.net/Justin_zhao/article/details/74358828)

**volatile**

多线程并发访问对象的变量时。对象的变量被拷贝到线程的内存区域。多线程并发访问不正确。

**CAS（Compare And Swap） 无锁算法**
CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

[学习链接](https://www.cnblogs.com/Mainz/p/3546347.html)

**JNI**

Java Natibe Inetrface：Java 是跨平台的语言，但是在有些时候仍然是有需要调用本地代码。

**其它**
* a = a + b，当类型不匹配时会报错。a += b，则会自动转换。

**类的实例化顺序**

* 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
* 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
结论：对象初始化的顺序，先静态方法，再构造方法，每个又是先基类后子类
* 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
* 父类构造方法
* 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
* 子类构造方法

**Class.forName和ClassLoader的区别**

对于Class.forName()，这个方法是Class类的一个static成员。Class对象就和其他对象一样，我们可以获取并操作他的引用。forName()是取得Class对象引用的一种方法。他是用一个包含目标类的文本名的String作为输入参数，返回一个Class对象的引用。forName()方法发现某个类还没被加载，就会主动去加载这个类，在加载过程中，该类的是static子句将会被执行。

**Java类装载过程**

* 装载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象；
* 链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；
	* 校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证）
	* 准备：给类的静态变量分配并初始化存储空间； 
	* 解析：将常量池中的符号引用转成直接引用； 
* 初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。 

**wait和sleep的区别**

* sleep来自Thread类，和wait来自Object类
* 调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁
* sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU
* sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒

**一致性哈希**

**java自动装箱拆箱深入剖析**

**谈谈Java反射机制**

**如何写一个不可变类**

**HashMap & ConcurrentHashMap**

**显示锁&内置锁的区别**